#!/usr/bin/perl -w
use strict;
use IO::Socket::INET;
use IO::File;
use Errno qw/EINTR EAGAIN/;
use POSIX qw(setsid);
use Getopt::Long;
use File::Copy;

use vars qw($VERSION $REVISION);
$VERSION='0.05';
$REVISION='$Id: xao-server,v 1.20 2007/04/06 21:51:17 am Exp $';

sub chld_handler ();
sub pipe_handler ();
sub dprint (@);
sub open_stream ($;@);
sub printsock (@);
sub reopen_log ();

my $log_file;
my $no_daemon;
my $pid_file;
my $debug;
my $tcpport=9010;

GetOptions(
    'debug'		=> \$debug,
    'log-file=s'	=> \$log_file,
    'no-daemon'		=> \$no_daemon,
    'pid-file=s'	=> \$pid_file,
    'port=i'		=> \$tcpport,
);

if(@ARGV<1) {
    print <<EOT;
Usage: $0 \\
        [--debug] \\
        [--log-file FILE] \\
        [--no-daemon] \\
        [--pid-file FILE] \\
        [--port $tcpport] \\
        SystemUnit

Starts the server that lets website talk to p21 backend for the given
system unit. TCP port can be set with '--port' option.

By default the server will detach from the terminal and go into
background. To change that use '--no-daemon' option.

EOT
    exit 1;
}
my $systemunit=int(shift @ARGV);
if(@ARGV) {
    dprint "Deprecated use, port should be specified with --port option";
    $tcpport=$ARGV[0];
}

my $spooldir="/tmp/webord$systemunit";
my $p21dir="/opt/xao/p21";

my $ServerName='xao-server ' . $systemunit . ' ' . $tcpport;
$0="$ServerName [master]";

###############################################################################

if(!$no_daemon) {
    my $pid=fork;
    die "Can't fork: $!" unless defined $pid;
    if($pid) {
	print STDERR "XAO P21 Server Started (unit=$systemunit, port=$tcpport)\n" if $debug;
        sleep 3;
        exit 0;
    }
    setsid();
    close(STDIN);
    open(STDIN,"</dev/null");
    close(STDOUT);
    open(STDOUT,">/dev/null");
    close(STDERR);
    open(STDERR,">/dev/null");
}
else {
    # Apparently we still need this, otherwise we get SIGTTOU from
    # the system when we execute p21 scripts (custinfo for instance).
    #
    ### setsid();
}

reopen_log();
dprint "XAO P21 Server Started (unit=$systemunit, port=$tcpport)";

my $main_pid=$$;
if($pid_file) {
    dprint "Pid file is in $pid_file";
    if(!open(F,">$pid_file")) {
        dprint "ERROR, can't open $pid_file: $!\n";
    }
    else {
        print F "$main_pid\n";
        close(F);
    }
}

chdir '/';

my $pipe_flag;;
my $socket;
my %children;
my $child_pid=$$;

$SIG{CHLD}=\&chld_handler;
$SIG{HUP}=\&reopen_log;
$SIG{TERM}=\&term_handler;
$SIG{INT}=\&term_handler;

$ENV{TERM}='dumb';
$ENV{HOME}='/tmp';

my $server=IO::Socket::INET->new(
    Proto	=> 'tcp',
    Listen	=> 10,
    LocalPort	=> $tcpport,
    Reuse	=> 1,
    LocalAddr	=> '127.0.0.1',
);
if(!$server) {
    dprint "*** Can't create server at $tcpport: $!";
    die "Cannot create server at $tcpport: $!\n\n";
}

my $master_start=time;
while(1) {
    $0 = "$ServerName [master, slaves#=".(scalar keys %children).", tm=".(time-$master_start)."s]";

    $pipe_flag=0;
    $socket=$server->accept;

    unless(defined $socket) {
        next if $!{EINTR} || $!{EAGAIN};
        dprint "Error accepting connection: $!";
        sleep 5;
        next;
    }

    $child_pid=fork;
    if(!defined $child_pid) {
        dprint "Can't fork: $!";
        sleep 10;
        next;
    }

    if($child_pid) {
        $children{$child_pid}=1;
        $socket->close;
        next;
    }

    $0="$ServerName [slave, waiting for first command]";

    $SIG{CHLD}='DEFAULT';
    $SIG{HUP}='DEFAULT';
    $SIG{PIPE}=\&pipe_handler;
    $SIG{TERM}='DEFAULT';
    $SIG{INT}='DEFAULT';

    $socket->autoflush(1);

    my $job_count=0;
    my $job_start=time;
    while(my $line=$socket->getline) {
        chop($line) while $line=~/[\r\n]$/;
        my ($opcode, @args) = split(/\t/,$line);
        next unless $opcode;

        my $now=time;
        dprint "Got cmd='$opcode' args='",join('|',@args),"' now=".localtime($now);

        ++$job_count;
        $0 = "$ServerName [slave, ct=$job_count, tm=".($now-$job_start)."s, cmd=$opcode]";

        if($pid_file && $now-(stat($pid_file))[9] > 60) {
            utime $now,$now,$pid_file;
        }

=head1 items

Returns full items list from "item" table; items delimited with '\n',
and each record contains: item code, package size, sales unit, sku,
list price, alternate unit name or "?", alternate unit size or "?",
description string 1, description string 2. All the fields delimited
with "\t".

=cut  

        if($opcode eq "items") {
            my $in = open_stream "items";
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 stock

Returns stock availability info for the given item code. The locaction 0
contains a summary of all actual location.

=cut  

        elsif ($opcode eq 'stock') {
            foreach my $item_code (@args) {
                my $in=open_stream('stock',$item_code);
                while(<$in>) {
                    printsock $_;
                }
                close($in);
            }
        }

=head1 blanket

Returns a description of the given blanket order.

=cut

        elsif ($opcode eq "blanket") {
            foreach my $order_id (@args) {
                my $in=open_stream('blanket',$order_id);
                while(<$in>) {
                    s/\t/ /g; s/\001/\t/g;
                    printsock $_;
                }
                close($in);
            }
        }

=head1 catalog

Returns full catalog items list. See "items" for data layout and
attributes order.

=cut  

        elsif ($opcode eq "catalog") {
            my $in = open_stream "catalog";
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 sell_schd

Returns a dump of sell_schd table containing price breaks data.

=cut  

        elsif ($opcode eq "sell_schd") {
            my $in = open_stream "sell_schd";
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 cust_item

Returns a dump of cust_item relevant for calculating fixed
customer specific prices.

=cut  

        elsif ($opcode eq "cust_item") {
            my $in = open_stream "cust_item";
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 custinfo

Returns info about customers. If no customer code is given in the
first argument then all customers list is returned.

=cut  

        elsif ($opcode eq "custinfo") {
            if(@args) {
                foreach (@args) {
                    my $in=open_stream('custinfo1',$_);
                    while(<$in>) {
                        s/\t/ /g; s/\001/\t/g;
                        printsock "$_";
                    }
                    close($in);
                }
            }
            else {
                my $in=open_stream 'custinfo';
                while(<$in>) {
                    next if /^(OK)*\s*$/;
                    s/\t/ /g; s/\001/\t/g;
                    printsock "$_";
                }
                close($in);
            }
        }

=head1 custcreate

Creates a customer with a predefined cust-code.

=cut  

        elsif ($opcode eq 'custcreate') {
            my $basename = $args[0];
            my $fname = "$spooldir/$basename.cust";
            eval {
                scalar(@args)==33 || die "Wrong number of arguments - got ".scalar(@args)." for $basename";
                pop @args;  # removing space keeper

                open(OUT,">$fname~") or die "$!";
                print OUT '"'.join('","',map { s/"/""/g; $_ } @args).qq(",\n);
                close(OUT) or die "$!";

                rename("$fname~", $fname) or die "$!";
            };
            if($@) {
                my $err=$@;
                chop($err) while $err=~/[\r\n\s]$/s;
                printsock "1\t$err\n";
                # unlink "$fname~" unless you_want_to_check_later;
            } else {
                printsock "0\t$basename\n";
            }
        }

=head1 edi_fetch

=cut

        elsif ($opcode eq "edi_fetch") {
            my $in=open_stream('edi_fetch',$args[0]);
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 order_entry

Placing order into spool. Input data is:

=cut  

        elsif ($opcode eq "order_entry") {
            my $basename = $args[0];
            my $fname = "$spooldir/$basename.proc";
            my $rname = "$spooldir/$basename.release";
            eval {
                (scalar(@args)%41)==0 || die "Wrong number of arguments";

                my @rdata;

                open(PROC_OUT,">$fname~") or die "$!";
                while(@args) {
                    my @line=map { defined $_ ? $_ : '' } splice(@args,0,41);

                    my $stext=$line[40];
                    if($stext && $stext ne 'N') {
                        $line[40]='Y';

                        my $lnum=$line[15] || die "No line number";

                        foreach my $d (split(/\|/,$stext)) {
                            push(@rdata,[ $lnum, split(/:/,$d) ]);
                        }
                    }
                    else {
                        $line[40]='';
                    }

                    foreach(@line) {
                        s/"/""/sg;
                        s/[\r\n\t]/ /sg;
                    }

                    print PROC_OUT '"', join('","', @line), qq(",\n) ;
                }
                close(PROC_OUT) or die "$!";

                if(@rdata) {
                    open(REL_OUT,">$rname") || die "Can't write $rname: $!";
                    foreach my $d (@rdata) {
                        print REL_OUT '"',join('","',@$d),qq("\n);
                    }
                    close(REL_OUT);
                }

                rename("$fname~", $fname) or die "$!";
            };
            if($@) {
                my $err=$@;
                chop($err) while $err=~/[\r\n\s]$/s;
                printsock "1\t$err\n";
                # unlink "$fname~" unless you_want_to_check_later;
            } else {
                printsock "0\t$basename\n";
            }
        }

=head1 view_open_order_details

=cut

        elsif ($opcode eq "view_order_details") {
            my $in=open_stream('ord_status',$args[0]);
            while(<$in>) {
                s/\t/ /g;
                s/\001/\t/g;
                printsock $_;
            }
            close($in);
        }

=head1 price

Asks for price. Input data is: customer code or "?", item code, quantity.
Output: price for one unit, multiplier.

=cut  

        elsif ($opcode eq "price") {
            my $in=open_stream('price',$args[0],$args[1],99,99,$args[2]);
            my $line = <$in>;
            printsock $line;
            close($in);
        }

=head1 find_match

=cut

        elsif ($opcode eq 'find_match') {
            opendir DH, "$spooldir" or die "$!";
            my %files ;
            foreach (readdir DH) {
                if (/([A-Za-z0-9_]+)\.[^.]+\.(\d+)/) {
                    $files{$1}=[$_, $2 ];
                }
            }
            closedir DH;
            foreach (@args) {
                printsock "$_\t$files{$_}->[0]\t$files{$_}->[1]\n" if defined $files{$_};
            }
        }

=head1 show_spool

=cut

        elsif ($opcode eq 'show_spool') {
            opendir DH, "$spooldir" or die $!;
            foreach (readdir DH) {
                next if /^\./;
                next unless /.+\..+/;
                printsock "$_\n";
            }
            closedir DH;
        }

=head1 cleanup_spool

=cut

        elsif ($opcode eq 'cleanup_spool') {
            foreach my $file (@args) {
                next unless $file =~ /^\w+[\w\.-]*$/;
                move("$spooldir/$file","$spooldir/archive/$file");
            }
        }

=head1 mod_custinfo

=cut

        #elsif ($opcode eq 'mod_custinfo') {
        #    foreach (0..12) {
        #        $ENV{"P$_"} = $args[$_];
        #    }
        #    system qq(/usr/lpp/p21pro/bin/p21pro) .
        #           qq( -S $systemunit) .
        #           qq( -d /usr/lpp/p21pro/src:/usr/lpp/p21pro/src/include) .
        #           qq( -p "-p $p21dir/modcust.p -b" > /dev/null) || die $!;
        #}

=head1 ord_past

Returns info about ordered items shipped past specified date.
Date is given as year, month date -- three integers.

=cut  

        elsif ($opcode eq "ord_past") {
            if(@args!=3) {
                printsock "ERROR: Bad syntax, expected YYYY MM DD\n";
            }
            else {
                my $in=open_stream('ord_past',@args);
                while(<$in>) {
                    s/\t/ /g; s/\001/\t/g;
                    printsock "$_";
                }
                close($in);
            }
        }

=head1 ping

Simply asks for 'PONG' and updates server's pid file timestamp so
that monitor can see that the server is alive.

=cut
        elsif($opcode eq 'ping') {
            printsock "PONG\n";
        }

=head1 isalive

Checks if some of the P21 data tables are available and shows their names
separated by forward slashes.

=cut  

        elsif ($opcode eq "isalive") {
            my $in = open_stream "isalive";
            while(<$in>) {
                printsock $_;
            }
            close($in);
        }

=head1 quit

Finish current session and disconnect.

=cut

        elsif($opcode eq 'quit') {
            printsock "Good bye\n";
            last;
        }

=head1 puser

Reads user permissions and passwords.

=cut

        elsif($opcode eq 'puser') {
            ##
            # First reading users config to understand who belongs to what system and
            # what ID maps to what unix logname
            #
            my $fd=IO::File->new('/usr/lpp/p21/config/users','r');
            if(!$fd) {
                printsock "Error reading users config\n";
            }
            else {
                my $buf;
                $fd->read($buf,32);
                my @users;
                while($fd->read($buf,260)==260) {
                    my ($foo1,$logname,$foo2,$syst_def,$syst_mask,$foo3,$p21_id)=
                        unpack('a4Z16a21CCa89Z16',$buf);
                    push(@users,{
                        logname     => $logname,
                        syst_default=> $syst_def,
                        syst_mask   => $syst_mask,
                        p21_id      => $p21_id,
                    });
                }
                $fd->close();

                ##
                # Reading a map between lognames and "generics" that are
                # useful for generic@rshughes.com emails.
                #
                $fd=IO::File->new('/etc/mail/genericstable','r');
                my %generics;
                if($fd) {
                    while(my $str=$fd->getline) {
                        chop $str while $str=~/[\r\n\s]$/;
                        my ($logname,$generic)=split(/\s/,$str);
                        next unless $logname && $generic;
                        $generics{lc($logname)}=lc($generic);
                    }
                    $fd->close;
                }

                ##
                # Now reading P21 data, skipping users defaulting to unit1. If the user has no P21 id
                # set up we still let them flow, otherwise pretty much everybody gets excluded.
                # Also, if system mask is not set at all - we allow such users.
                # (this all is according to conversation with Greg, might need adjustment if
                # p21 is updated)
                #
                my $in = open_stream 'puser';
                while(<$in>) {
                    s/\t/ /g;
                    chop while /[\r\n]$/;
                    my @a=split(/\001/,$_);
                    if(@a!=4) {
                        printsock "Wrong data\n";
                        last;
                    }
                    elsif($a[0]) {
                        my $p21_id=$a[0];
                        my @ud=grep { $_->{'p21_id'} eq $p21_id || lc($_->{'logname'}) eq lc($p21_id) } @users;
                        if(@ud && $ud[0]->{'syst_default'}==0 && (!$ud[0]->{'syst_mask'} || ($ud[0]->{'syst_mask'}&0x01))) {
                            my @pwdata=getpwnam($ud[0]->{'logname'});
                            my $password=@pwdata && $pwdata[0] && $pwdata[1] ? $pwdata[1] : '**';
                            printsock join("\t",@a,$password,$generics{lc($ud[0]->{'logname'})})."\n";
                        }
                        else {
                            dprint "skipping $p21_id";
                            if(@ud) {
                                dprint ".$ud[0]->{syst_default}..$ud[0]->{syst_mask}..$ud[0]->{logname}";
                            }
                        }
                    }
                }
                close($in);
            }
        }

=head1 units - a table on unit_name/description pairs

=cut

        elsif($opcode eq 'units') {
            my $in=open_stream 'units';
            while(<$in>) {
                printsock "$_";
            }
            close($in);
        }

=head1 undefined command

=cut  

        else {
            printsock "undefined command\n";
        }

        printsock ".\n";
    }

    $socket->close;

    exit 0;
}

exit 0;

###############################################################################

sub printsock (@) {
    ### dprint "PRINTSOCK: ",@_;
    print $socket @_;
    die $! if $pipe_flag;
}

sub dprint (@) {
    return unless $debug;
    my $text=join('',map { defined($_) ? $_ : '<UNDEF>' } @_);
    print STDERR "SERVER($$): $text";
    print STDERR "\n" unless $text=~/\n$/s;
}

sub open_stream ($;@) {
    my $script=shift;
    for(my $i=0; $i!=@_; $i++) {
        $ENV{"P$i"}=$_[$i];
    }
    local *IN;
    open IN, qq(/usr/lpp/p21pro/bin/p21pro) .
             qq( -S $systemunit) .
             qq( -d /usr/lpp/p21pro/src:/usr/lpp/p21pro/src/include) .
             qq( -p "-p $p21dir/$script.p -b"|) || die $!;
    return *IN;  
}

sub reopen_log () {
    return unless $log_file;
    close STDERR;
    if(-f $log_file && (stat($log_file))[7] > 1000000) {
        -f "$log_file.4" && rename("$log_file.4","$log_file.5");
        -f "$log_file.3" && rename("$log_file.3","$log_file.4");
        -f "$log_file.2" && rename("$log_file.2","$log_file.3");
        -f "$log_file.1" && rename("$log_file.1","$log_file.2");
        rename("$log_file","$log_file.1");
    }
    if(open(STDERR,">>$log_file")) {
        print STDERR "===========================" .
                     " pid=$$ unit=$systemunit port=$tcpport" .
                     " time=".scalar(localtime)."\n";
        select STDERR;
        $|=1;
    }
}

sub chld_handler () {
    my $pid=wait;
    if($pid>0) {
        if($children{$pid}) {
            dprint "Child $pid exited";
            delete $children{$pid};
        }
        else {
            dprint "Child process exited";
        }
    }
    else {
        dprint "Stray CHLD signal";
    }
    $SIG{CHLD}=\&chld_handler;
}

sub pipe_handler () {
    $pipe_flag=1;
}

sub term_handler () {
    if($child_pid) {
        foreach my $pid (keys %children) {
            dprint "Killing child $pid";
            kill 15,$pid;
        }
        if($pid_file) {
            dprint "Unlinking $pid_file";
            unlink $pid_file;
        }
        dprint "Terminating";
    }
    sleep(10);
    exit 1;
}
