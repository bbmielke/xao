#!/usr/bin/perl -w
use strict;
use IO::Socket::INET;
use Errno qw/EINTR EAGAIN/;
use POSIX qw(setsid);
use Getopt::Long;
use File::Copy;

use vars qw($VERSION $REVISION);
$VERSION='0.05';
$REVISION='$Id: xao-server,v 1.6 2005/09/07 23:53:15 am Exp $';

sub chld_handler ();
sub dprint (@);
sub open_local_query (@);
sub open_query (@);
sub open_stream ($);
sub pipe_handler ();
sub printsock (@);
sub reopen_log ();

my $log_file;
my $no_daemon;
my $pid_file;
my $debug;
my $tcpport=9010;

GetOptions(
    'debug'		=> \$debug,
    'log-file=s'	=> \$log_file,
    'no-daemon'		=> \$no_daemon,
    'pid-file=s'	=> \$pid_file,
    'port=i'		=> \$tcpport,
);

if(@ARGV<1) {
    print <<EOT;
Usage: $0 \\
        [--debug] \\
        [--log-file FILE] \\
        [--no-daemon] \\
        [--pid-file FILE] \\
        [--port $tcpport] \\
        SystemUnit

Starts the server that lets website talk to p21 backend for the given
system unit. TCP port can be set with '--port' option.

By default the server will detach from the terminal and go into
background. To change that use '--no-daemon' option.

EOT
    exit 1;
}
my $systemunit=int(shift @ARGV);
if(@ARGV) {
    dprint "Deprecated use, port should be specified with --port option";
    $tcpport=$ARGV[0];
}

my $spooldir="/tmp/webord$systemunit";
my $p21dir="/opt/xao/p21";

my $ServerName='xao-server ' . $systemunit . ' ' . $tcpport;
$0 = $ServerName;

###############################################################################

if(!$no_daemon) {
    my $pid=fork;
    die "Can't fork: $!" unless defined $pid;
    if($pid) {
	print STDERR "XAO P21 Server Started (unit=$systemunit, port=$tcpport)\n" if $debug;
        sleep 3;
        exit 0;
    }
    setsid();
    close(STDIN);
    open(STDIN,"</dev/null");
    close(STDOUT);
    open(STDOUT,">/dev/null");
    close(STDERR);
    open(STDERR,">/dev/null");
}
else {
    # Apparently we still need this, otherwise we get SIGTTOU from
    # the system when we execute p21 scripts (custinfo for instance).
    #
    setsid();
}
dprint "XAO P21 Server Started (unit=$systemunit, port=$tcpport)";

reopen_log();

my $main_pid=$$;
if($pid_file) {
    dprint "Pid file is in $pid_file";
    if(!open(F,">$pid_file")) {
        dprint "ERROR, can't open $pid_file: $!\n";
    }
    else {
        print F "$main_pid\n";
        close(F);
    }
}

chdir '/';

my $pipe_flag;;
my $socket;
my %children;
my $child_pid=$$;

$SIG{CHLD}=\&chld_handler;
$SIG{HUP}=\&reopen_log;
$SIG{PIPE}=\&pipe_handler;
$SIG{TERM}=\&term_handler;
$SIG{INT}=\&term_handler;

$ENV{TERM}='ansi' unless $ENV{TERM}; # P21 scripts apparently need it

my $server=IO::Socket::INET->new(
    Proto	=> 'tcp',
    Listen	=> 10,
    LocalPort	=> $tcpport,
    Reuse	=> 1,
    LocalAddr	=> '127.0.0.1',
);
if(!$server) {
    dprint "*** Can't create server at $tcpport: $!";
    die "Cannot create server at $tcpport: $!\n\n";
}

while(1) {
    $pipe_flag=0;
    $socket=$server->accept;

    unless(defined $socket) {
        next if $!{EINTR} || $!{EAGAIN};
        dprint "Error accepting connection: $!";
        sleep 5;
        next;
    }

    $child_pid=fork;
    if(!defined $child_pid) {
        $child_pid=$$;
        dprint "Can't fork: $!";
        sleep 10;
        next;
    }

    if($child_pid) {
        $children{$child_pid}=1;
        $socket->close;
        next;
    }

    $socket->autoflush(1);

    my $answer = sub {
        my $in = open_query @_;
        while(<$in>) {
            next if /^(OK)*\s*$/;
            s/\t/ /g; s/\001/\t/g;
            printsock $_;
        }
    };
    
    my $answer_local = sub {
        my $in = open_local_query @_;
        while(<$in>) {
            next if /^(OK)*\s*$/;
            s/\t/ /g; s/\001/\t/g;
            printsock $_;
        }
    };
    
    while(<$socket>) {
        chop while /[\r\n]$/;
        my ($opcode, @args) = split /\t/;
        next unless $opcode;

        my $now=time;
        dprint "Got cmd='$opcode' args='",join('|',@args),"' now=$now";

	if($pid_file && $now-(stat($pid_file))[9] > 60) {
            utime $now,$now,$pid_file;
        }

        $0 = "$ServerName $opcode";

=head1 items

Returns full items list from "item" table; items delimited with '\n',
and each record contains: item code, package size, sales unit, sku,
list price, alternate unit name or "?", alternate unit size or "?",
description string 1, description string 2. All the fields delimited
with "\t".

=cut  

        if($opcode eq "items") {
            my $in = open_stream "items";
            while(<$in>) {
                printsock $_;
            }

=head1 avail

Returns availability info for each of given item code. The info contains lines with non-zero quantities only.  

=cut  

        }

        elsif ($opcode eq "avail") {
            foreach my $code (@args) {
                my $in = open_query 'stk_item', '?', $code;
                while(<$in>) {
                    next if /^(OK)*\s*$/;
                    s/\t/ /g; s/\001/\t/g;
                    my ($location, $stock, @rest) = split /\t/;
                    printsock "$code\t$_" if ($stock);
                }
            }
        }

=head1 blanket

Returns a description of the given blanket order.

=cut

        elsif ($opcode eq "blanket") {
            foreach my $order_id (@args) {
                $ENV{"P0"} = $order_id;
                my $in = open_stream 'blanket';
                while(<$in>) {
                    s/\t/ /g; s/\001/\t/g;
                    printsock $_;
                }
            }
        }

=head1 catalog

Returns full catalog items list. See "items" for data layout and
attributes order.

=cut  

        elsif ($opcode eq "catalog") {
            my $in = open_stream "catalog";
            while(<$in>) {
                printsock $_;
            }
        }

=head1 sell_schd

Returns a dump of sell_schd table containing price breaks data.

=cut  

        elsif ($opcode eq "sell_schd") {
            my $in = open_stream "sell_schd";
            while(<$in>) {
                printsock $_;
            }
        }

=head1 cust_item

Returns a dump of cust_item relevant for calculating fixed
customer specific prices.

=cut  

        elsif ($opcode eq "cust_item") {
            my $in = open_stream "cust_item";
            while(<$in>) {
                printsock $_;
            }
        }

=head1 custinfo

Returns info about customers. If no customer code is given in the
first argument then all customers list is returned.

=cut  

        elsif ($opcode eq "custinfo") {
            if(@args) {
                foreach (@args) {
                    $ENV{"P0"} = $_;
                    my $in = open_stream 'custinfo1';
                    while(<$in>) {
                        s/\t/ /g; s/\001/\t/g;
                        printsock "$_";
                    }
                }
            }
            else {
                my $in=open_stream 'custinfo';
                while(<$in>) {
                    next if /^(OK)*\s*$/;
                    s/\t/ /g; s/\001/\t/g;
                    printsock "$_";
                }
            }
        }

=head1 order

Placing order into spool. Input data is:

=cut  

        elsif ($opcode eq "order_entry") {
            my $basename = $args[0];
            my $fname = "$spooldir/$basename.proc";
            my $rname = "$spooldir/$basename.release";
            eval {
                (scalar(@args)%41)==0 || die "Wrong number of arguments";

                my @rdata;

                open(PROC_OUT,">$fname~") or die "$!";
                while(@args) {
                    my @line=map { defined $_ ? $_ : '' } splice(@args,0,41);

                    my $stext=$line[40];
                    if($stext) {
                        $line[40]='Y';

                        my $lnum=$line[15] || die "No line number";

                        foreach my $d (split(/\|/,$stext)) {
                            push(@rdata,[ $lnum, split(/:/,$d) ]);
                        }
                    }
                    else {
                        $line[40]='N';
                    }

                    foreach(@line) {
                        s/"/'/sg;
                    }

                    print PROC_OUT '"', join('","', @line), qq(",\n) ;
                }
                close(PROC_OUT) or die "$!";

                if(@rdata) {
                    open(REL_OUT,">$rname") || die "Can't write $rname: $!";
                    foreach my $d (@rdata) {
                        print REL_OUT '"',join('","',@$d),qq("\n);
                    }
                    close(REL_OUT);
                }

                rename("$fname~", $fname) or die "$!";
            };
            if($@) {
                printsock "1\t$@\n";
                # unlink "$fname~" unless you_want_to_check_later;
            } else {
                printsock "0\t$basename\n";
            }
        }

=head1 view_open_order_details

=cut

	elsif ($opcode eq "view_order_details") {
            $answer_local->('ord_status', @args);
        }

=head1 price

Asks for price. Input data is: customer code or "?", item code, quantity.
Output: price for one unit, multiplier.

=cut  

        elsif ($opcode eq "price") {
            $ENV{P0} = $args[0] eq '?' ? "" : $args[0];
            $ENV{P1} = $args[1];
            $ENV{P2} = 99;   #   XXX
            $ENV{P3} = 99;   #   XXX
            $ENV{P4} = $args[2];
            my $in = open_stream "price";
            my $line = <$in>;
            printsock $line;
        }

=head1 find_match

=cut

        elsif ($opcode eq 'find_match') {
            opendir DH, "$spooldir" or die "$!";
            my %files ;
            foreach (readdir DH) {
                if (/([A-Za-z0-9_]+)\.[^.]+\.(\d+)/) {
                    $files{$1}=[$_, $2 ];
                }
            }
            closedir DH;
            foreach (@args) {
                printsock "$_\t$files{$_}->[0]\t$files{$_}->[1]\n" if defined $files{$_};
            }
        }

=head1 show_spool

=cut

        elsif ($opcode eq 'show_spool') {
            opendir DH, "$spooldir" or die $!;
            foreach (readdir DH) {
                next unless /\..*\./;
                printsock "$_\n" unless /^\./;
            }
            closedir DH;
        }

=head1 cleanup_spool

=cut

        elsif ($opcode eq 'cleanup_spool') {
            foreach my $file (@args) {
            	next unless $file =~ /^\w+[\w\.-]*$/;
            	move("$spooldir/$file","$spooldir/archive/$file");
            }
        }

=head1 mod_custinfo

=cut

        elsif ($opcode eq 'mod_custinfo') {
            foreach (0..12) {
                $ENV{"P$_"} = $args[$_];
            }
            system qq(/usr/lpp/p21pro/bin/p21pro) .
                   qq( -S $systemunit) .
                   qq( -d /usr/lpp/p21pro/src:/usr/lpp/p21pro/src/include) .
                   qq( -p "-p $p21dir/modcust.p -b" > /dev/null) || die $!;
        }

=head1 ord_past

Returns info about ordered items shipped past specified date.
Date is given as year, month date -- three integers.

=cut  

        elsif ($opcode eq "ord_past") {
            if(@args<3) {
                printsock "ERROR: Bad syntax, expected YYYY MM DD\n";
            }
            else {
                $ENV{"P0"}=$args[0];
                $ENV{"P1"}=$args[1];
                $ENV{"P2"}=$args[2];
                my $in = open_stream 'ord_past';
                while(<$in>) {
                    s/\t/ /g; s/\001/\t/g;
                    printsock "$_";
                }
            }
        }

=head1 ping

Simply asks for 'PONG' and updates server's pid file timestamp so
that monitor can see that the server is alive.

=cut
        elsif($opcode eq 'ping') {
            printsock "PONG\n";
        }

=head1 quit

Finish current session and disconnect.

=cut

        elsif($opcode eq 'quit') {
            printsock "Good bye\n";
            last;
        }

=head1 undefined command

=cut  

        else {
            printsock "undefined command\n";
        }

        printsock ".\n";
    }

    $socket->close;

    exit 0;
}

exit 0;

###############################################################################

sub printsock (@) {
    dprint "PRINTSOCK: ",@_;
    print $socket @_;
    die $! if $pipe_flag;
}

sub dprint (@) {
    return unless $debug;
    my $text=join('',map { defined($_) ? $_ : '<UNDEF>' } @_);
    print STDERR "SERVER($$): $text";
    print STDERR "\n" unless $text=~/\n$/s;
}

sub open_stream ($) {
    local *IN;
    my $script=shift;
    open IN, qq(/usr/lpp/p21pro/bin/p21pro) .
             qq( -S $systemunit) .
             qq( -d /usr/lpp/p21pro/src:/usr/lpp/p21pro/src/include) .
             qq( -p "-p $p21dir/$script.p -b"|) || die $!;
    return *IN;  
}

sub open_query (@) {
    local *IN;
    $ENV{'PROCNAME'}=shift;
    my $envn=0; 
    foreach (@_) {
        $ENV{"P$envn"}=$_;
        ++$envn;
    }
    $ENV{ORIGIN}='P21';
    open IN, qq(/usr/lpp/p21pro/bin/p21pro -S $systemunit -P p21/www/query/www.p -p -b|) ||
        die $!;
    *IN;  
}

sub open_local_query (@) {
    my $script=shift;
    local *IN;
    for(my $i=0; $i!=@_; $i++) {
        $ENV{"P$i"}=$_[0];
    }
    open IN, qq(/usr/lpp/p21pro/bin/p21pro) .
             qq( -S $systemunit) .
             qq( -d /usr/lpp/p21pro/src:/usr/lpp/p21pro/src/include) .
             qq( -p "-p $p21dir/$script.p -b"|) || die $!;
    *IN;  
}

sub reopen_log () {
    return unless $log_file;
    close STDERR;
    if(open(STDERR,">>$log_file")) {
        print STDERR "===========================" .
                     " pid=$$ unit=$systemunit port=$tcpport" .
                     " time=".scalar(localtime)."\n";
    	select STDERR;
    	$|=1;
    }
}

sub chld_handler () {
    my $pid=wait;
    if($pid>0) {
        dprint "Child $pid exited";
        delete $children{$pid};
    }
    $SIG{CHLD}=\&chld_handler;
}

sub pipe_handler () {
    $pipe_flag=1;
}

sub term_handler () {
    if($child_pid) {
        foreach my $pid (keys %children) {
            dprint "Killing child $pid";
            kill 15,$pid;
        }
        if($pid_file) {
            dprint "Unlinking $pid_file";
            unlink $pid_file;
        }
        dprint "Terminating";
    }
    exit 1;
}
